#pragma once
/// This file is generated by gen_ir_def.py
#include <type_traits>
#include <luisa/ir_v2/ir_v2_fwd.h>
namespace luisa::compute::ir_v2 {

struct PhiIncoming {
    const BasicBlock *block = nullptr;
    const Node *value = nullptr;
};
struct SwitchCase {
    int32_t value = 0;
    const BasicBlock *block = nullptr;
};

struct Func {
public:
    enum class Tag {
        Add,
        Sub,
        Mul,
        Div,
        Mod,
        Min,
        Max,
        Pow,
        Sin,
        Cos,
        Tan,
        Asin,
        Acos,
        Atan,
        Load,
        Store,
        GetElementPtr,
        ExtractElement,
        InsertElement,
        Vec,
        Vec2,
        Vec3,
        Vec4,
        MatFull,
        Mat2,
        Mat3,
        Mat4,
        Cast,
        BitCast,
        BufferWrite,
        BufferRead,
        BufferSize,
        ByteBufferWrite,
        ByteBufferRead,
        ByteBufferSize,
        AtomicFetchAdd,
        AtomicFetchSub,
        AtomicFetchAnd,
        AtomicFetchOr,
        AtomicFetchXor,
        AtomicFetchMin,
        AtomicFetchMax,
        BindlessBufferWrite,
        BindlessBufferRead,
        BindlessBufferSize,
        BindlessByteBufferWrite,
        BindlessByteBufferRead,
        BindlessByteBufferSize,
        BindlessAtomicFetchAdd,
        BindlessAtomicFetchSub,
        BindlessAtomicFetchAnd,
        BindlessAtomicFetchOr,
        BindlessAtomicFetchXor,
        BindlessAtomicFetchMin,
        BindlessAtomicFetchMax,
    };
    [[nodiscard]] virtual Tag tag() const noexcept = 0;
    template<class T>
        requires std::is_base_of_v<Func, T>
    [[nodiscard]] bool is() const noexcept {
        return tag() == T::Tag;
    }
    template<class T>
        requires std::is_base_of_v<Func, T>
    [[nodiscard]] T &as() {
        LUISA_ASSERT(is<T>());
        return static_cast<T &>(*this);
    }
    template<class T>
        requires std::is_base_of_v<Func, T>
    [[nodiscard]] const T &as() const {
        LUISA_ASSERT(is<T>());
        return static_cast<const T &>(*this);
    }

    [[nodiscard]] virtual bool has_side_effects() const noexcept = 0;
};
struct Add : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Add;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Sub : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Sub;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Mul : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Mul;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Div : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Div;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Mod : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Mod;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Min : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Min;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Max : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Max;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Pow : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Pow;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Sin : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Sin;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Cos : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Cos;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Tan : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Tan;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Asin : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Asin;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Acos : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Acos;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Atan : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Atan;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Load : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Load;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Store : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Store;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct GetElementPtr : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::GetElementPtr;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct ExtractElement : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::ExtractElement;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct InsertElement : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::InsertElement;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Vec : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Vec;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Vec2 : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Vec2;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Vec3 : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Vec3;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Vec4 : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Vec4;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct MatFull : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::MatFull;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Mat2 : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Mat2;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Mat3 : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Mat3;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Mat4 : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Mat4;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct Cast : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Cast;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct BitCast : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BitCast;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct BufferWrite : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BufferWrite;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct BufferRead : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BufferRead;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct BufferSize : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BufferSize;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct ByteBufferWrite : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::ByteBufferWrite;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct ByteBufferRead : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::ByteBufferRead;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct ByteBufferSize : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::ByteBufferSize;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct AtomicFetchAdd : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::AtomicFetchAdd;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct AtomicFetchSub : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::AtomicFetchSub;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct AtomicFetchAnd : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::AtomicFetchAnd;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct AtomicFetchOr : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::AtomicFetchOr;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct AtomicFetchXor : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::AtomicFetchXor;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct AtomicFetchMin : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::AtomicFetchMin;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct AtomicFetchMax : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::AtomicFetchMax;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct BindlessBufferWrite : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BindlessBufferWrite;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct BindlessBufferRead : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BindlessBufferRead;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct BindlessBufferSize : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BindlessBufferSize;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct BindlessByteBufferWrite : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BindlessByteBufferWrite;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct BindlessByteBufferRead : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BindlessByteBufferRead;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct BindlessByteBufferSize : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BindlessByteBufferSize;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return false;
    }
};
struct BindlessAtomicFetchAdd : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BindlessAtomicFetchAdd;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    const Type *ty;
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct BindlessAtomicFetchSub : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BindlessAtomicFetchSub;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    const Type *ty;
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct BindlessAtomicFetchAnd : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BindlessAtomicFetchAnd;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    const Type *ty;
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct BindlessAtomicFetchOr : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BindlessAtomicFetchOr;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    const Type *ty;
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct BindlessAtomicFetchXor : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BindlessAtomicFetchXor;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    const Type *ty;
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct BindlessAtomicFetchMin : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BindlessAtomicFetchMin;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    const Type *ty;
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct BindlessAtomicFetchMax : public Func {
public:
    using Func::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BindlessAtomicFetchMax;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    const Type *ty;
    [[nodiscard]] constexpr bool has_side_effects() const noexcept override {
        return true;
    }
};
struct Instruction {
public:
    enum class Tag {
        Const,
        Call,
        Phi,
        BasicBlockSential,
        If,
        GenericLoop,
        Switch,
        Local,
        Break,
        Continue,
        Return,
    };
    [[nodiscard]] virtual Tag tag() const noexcept = 0;
    template<class T>
        requires std::is_base_of_v<Instruction, T>
    [[nodiscard]] bool is() const noexcept {
        return tag() == T::Tag;
    }
    template<class T>
        requires std::is_base_of_v<Instruction, T>
    [[nodiscard]] T &as() {
        LUISA_ASSERT(is<T>());
        return static_cast<T &>(*this);
    }
    template<class T>
        requires std::is_base_of_v<Instruction, T>
    [[nodiscard]] const T &as() const {
        LUISA_ASSERT(is<T>());
        return static_cast<const T &>(*this);
    }
};
struct Const : public Instruction {
public:
    using Instruction::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Const;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    const Type *type;
    luisa::vector<uint8_t> value;
};
struct Call : public Instruction {
public:
    using Instruction::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Call;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    const Func *func;
    luisa::vector<Node *> args;
    Call(const Func *func, luisa::vector<Node *> args) noexcept {
        this->func = std::move(func);
        this->args = std::move(args);
    }
};
struct Phi : public Instruction {
public:
    using Instruction::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Phi;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    luisa::vector<PhiIncoming> incomings;
};
struct BasicBlockSential : public Instruction {
public:
    using Instruction::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::BasicBlockSential;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
};
struct If : public Instruction {
public:
    using Instruction::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::If;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    Node *cond;
    BasicBlock *true_branch;
    BasicBlock *false_branch;
    If(Node *cond, BasicBlock *true_branch, BasicBlock *false_branch) noexcept {
        this->cond = cond;
        this->true_branch = true_branch;
        this->false_branch = false_branch;
    }
};
struct GenericLoop : public Instruction {
public:
    using Instruction::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::GenericLoop;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    BasicBlock *prepare;
    Node *cond;
    BasicBlock *body;
    BasicBlock *update;
    GenericLoop(BasicBlock *prepare, Node *cond, BasicBlock *body, BasicBlock *update) noexcept {
        this->prepare = prepare;
        this->cond = cond;
        this->body = body;
        this->update = update;
    }
};
struct Switch : public Instruction {
public:
    using Instruction::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Switch;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    Node *value;
    luisa::vector<SwitchCase> cases;
    BasicBlock *default_;
    Switch(Node *value, luisa::vector<SwitchCase> cases, BasicBlock *default_) noexcept {
        this->value = value;
        this->cases = std::move(cases);
        this->default_ = default_;
    }
};
struct Local : public Instruction {
public:
    using Instruction::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Local;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    Node *init;
    Local(Node *init) noexcept {
        this->init = init;
    }
};
struct Break : public Instruction {
public:
    using Instruction::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Break;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
};
struct Continue : public Instruction {
public:
    using Instruction::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Continue;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
};
struct Return : public Instruction {
public:
    using Instruction::Tag;
    static constexpr Tag static_tag() noexcept {
        return Tag::Return;
    }
    [[nodiscard]] Tag tag() const noexcept override {
        return static_tag();
    }
public:
    Node *value;
    Return(Node *value) noexcept {
        this->value = value;
    }
};
}// namespace luisa::compute::ir_v2
