import os
from typing import List, Dict, Tuple, Optional, Union, Set

file = open('ir_v2_defs.h', 'w')
fwd_file = open('ir_v2_fwd.h', 'w')

print('#pragma once', file=file)
print('/// This file is generated by gen_ir_def.py', file=file)
print('#include <type_traits>', file=file)
print('#include <luisa/ir_v2/ir_v2_fwd.h>', file=file)
print('namespace luisa::compute::ir_v2 {', file=file)
print('namespace luisa::compute::ir_v2 {', file=fwd_file)
print('struct BasicBlock;', file=fwd_file)
print('struct Node;', file=fwd_file)


class Item:
    def __init__(self, name, fields: List[Tuple[str, str]]) -> None:
        self.cpp_src = ''
        self.name = name
        self.fields = fields

    def gen(self):
        out = 'public:\n'
        for field in self.fields:
            out += '    {} {};\n'.format(field[0], field[1])
        out += self.cpp_src
        return out


class Instruction(Item):
    def __init__(self, name, fields, cpp_src=None) -> None:
        super().__init__(name, fields)
        if cpp_src is not None:
            self.cpp_src = cpp_src


class Func(Item):
    def __init__(self, name, fields, side_effects=False) -> None:
        super().__init__(name, fields)
        self.side_effects = side_effects

    def gen(self):
        out = super().gen()
        out += '    [[nodiscard]] constexpr bool has_side_effects() const noexcept override{\n'
        out += '        return {};\n'.format(
            'true' if self.side_effects else 'false')
        out += '    }\n'
        return out


class IRType(Item):
    def __init__(self, name, fields, cpp_src=None) -> None:
        super().__init__(name, fields)
        if cpp_src is not None:
            self.cpp_src = cpp_src


def gen_adt_cpp(adt: str, cpp_src: str, variants: List[Item]):
    print('struct {};'.format(adt), file=fwd_file)
    for variant in variants:
        print('struct {};'.format(variant.name), file=fwd_file)
    print('struct {} {{'.format(adt), file=file)
    print('public:', file=file)
    print('    enum class Tag {', file=file)
    for variant in variants:
        print('        {},'.format(variant.name), file=file)
    print('    };', file=file)
    print('    [[nodiscard]] virtual Tag tag() const noexcept = 0;', file=file)
    print('    template<class T> requires std::is_base_of_v<{}, T> [[nodiscard]] bool is()const noexcept {{'.format(
        adt), file=file)
    print('        return tag() == T::Tag;', file=file)
    print('    }', file=file)
    print('    template<class T> requires std::is_base_of_v<{}, T> [[nodiscard]]  T& as() {{'.format(
        adt), file=file)
    print('        LUISA_ASSERT(is<T>());', file=file)
    print('        return static_cast<T&>(*this);', file=file)
    print('    }', file=file)
    print('    template<class T> requires std::is_base_of_v<{}, T> [[nodiscard]] const T& as()const {{'.format(
        adt), file=file)
    print('        LUISA_ASSERT(is<T>());', file=file)
    print('        return static_cast<const T&>(*this);', file=file)
    print('    }', file=file)
    print('    ', cpp_src, file=file)
    print('};', file=file)

    for variant in variants:
        print('struct {} : public {} {{'.format(variant.name, adt), file=file)
        print('public:', file=file)
        print('    using {}::Tag;'.format(adt), file=file)
        print('    static constexpr Tag static_tag() noexcept {', file=file)
        print('        return Tag::{};'.format(variant.name), file=file)
        print('    }', file=file)
        print(
            '    [[nodiscard]] Tag tag() const noexcept override {', file=file)
        print('        return static_tag();', file=file)
        print('    }', file=file)
        print('    ', variant.gen(), file=file)
        print('};', file=file)


instructions = [
    Instruction('Const', [
        ('const Type*', 'type'),
        ('luisa::vector<uint8_t>', 'value')
    ]),
    Instruction('Call', [
        ('const Func *', 'func'),
        ('luisa::vector<Node*>', 'args'),
    ], cpp_src='''Call(const Func* func, luisa::vector<Node*> args) noexcept {
        this->func = std::move(func);
        this->args = std::move(args);
}
'''),
    Instruction('Phi', [('luisa::vector<PhiIncoming>', 'incomings')]),
    Instruction("BasicBlockSential", []),
    Instruction('If', [
        ('Node*', 'cond'),
        ('BasicBlock*', 'true_branch'),
        ('BasicBlock*', 'false_branch')
    ], cpp_src='''If(Node* cond, BasicBlock* true_branch, BasicBlock* false_branch) noexcept {
    this->cond = cond;
    this->true_branch = true_branch;
    this->false_branch = false_branch;
}
'''),
    Instruction('GenericLoop', [
        ('BasicBlock*', 'prepare'),
        ('Node*', 'cond'),
        ('BasicBlock*', 'body'),
        ('BasicBlock*', 'update')
    ], cpp_src='''GenericLoop(BasicBlock* prepare, Node* cond, BasicBlock* body, BasicBlock* update) noexcept {
    this->prepare = prepare;
    this->cond = cond;
    this->body = body;
    this->update = update;
}
'''),
    Instruction('Switch', [
        ('Node*', 'value'),
        ('luisa::vector<SwitchCase>', 'cases'),
        ('BasicBlock*', 'default_')
    ], cpp_src='''Switch(Node* value, luisa::vector<SwitchCase> cases, BasicBlock* default_) noexcept {
    this->value = value;
    this->cases = std::move(cases);
    this->default_ = default_;
}'''),
    Instruction('Local', [
        ('Node*', 'init')
    ], cpp_src='''Local(Node* init) noexcept {
    this->init = init;
}'''),
    Instruction('Break', []),
    Instruction('Continue', []),
    Instruction('Return', [
        ('Node*', 'value')
    ], cpp_src='''Return(Node* value) noexcept {
    this->value = value;
}'''),
]

funcs = [


    Func('Add', []),
    Func('Sub', []),
    Func('Mul', []),
    Func('Div', []),
    Func('Mod', []),
    Func('Min', []),
    Func('Max', []),
    Func('Pow', []),
    Func('Sin', []),
    Func('Cos', []),
    Func('Tan', []),
    Func('Asin', []),
    Func('Acos', []),
    Func('Atan', []),


    Func('Load', []),
    Func('Store', [], side_effects=True),
    Func('GetElementPtr', []),
    Func('ExtractElement', []),
    Func('InsertElement', []),

    Func('Vec', []),
    Func('Vec2', []),
    Func('Vec3', []),
    Func('Vec4', []),

    Func('MatFull', []),
    Func('Mat2', []),
    Func('Mat3', []),
    Func('Mat4', []),

    Func('Cast', []),
    Func('BitCast', []),


    Func('BufferWrite', [], side_effects=True),
    Func('BufferRead', []),
    Func('BufferSize', []),

    Func('ByteBufferWrite', [], side_effects=True),
    Func('ByteBufferRead', []),
    Func('ByteBufferSize', []),

    Func('AtomicFetchAdd', [], side_effects=True),
    Func('AtomicFetchSub', [], side_effects=True),
    Func('AtomicFetchAnd', [], side_effects=True),
    Func('AtomicFetchOr', [], side_effects=True),
    Func('AtomicFetchXor', [], side_effects=True),
    Func('AtomicFetchMin', [], side_effects=True),
    Func('AtomicFetchMax', [], side_effects=True),


    Func('BindlessBufferWrite', [], side_effects=True),
    Func('BindlessBufferRead', []),
    Func('BindlessBufferSize', []),

    Func('BindlessByteBufferWrite', [], side_effects=True),
    Func('BindlessByteBufferRead', []),
    Func('BindlessByteBufferSize', []),

    Func('BindlessAtomicFetchAdd', [
         ('const Type *', 'ty')], side_effects=True),
    Func('BindlessAtomicFetchSub', [
         ('const Type *', 'ty')], side_effects=True),
    Func('BindlessAtomicFetchAnd', [
         ('const Type *', 'ty')], side_effects=True),
    Func('BindlessAtomicFetchOr', [('const Type *', 'ty')], side_effects=True),
    Func('BindlessAtomicFetchXor', [
         ('const Type *', 'ty')], side_effects=True),
    Func('BindlessAtomicFetchMin', [
         ('const Type *', 'ty')], side_effects=True),
    Func('BindlessAtomicFetchMax', [
         ('const Type *', 'ty')], side_effects=True),

]

FUNC_CPP_SRC = '''
[[nodiscard]] virtual bool has_side_effects() const noexcept = 0;
'''

print('''
struct PhiIncoming {
    const BasicBlock *block = nullptr;
    const Node *value = nullptr;
};
struct SwitchCase {
    int32_t value = 0;
    const BasicBlock *block = nullptr;    
};
''', file=file)
gen_adt_cpp("Func", FUNC_CPP_SRC, funcs)
gen_adt_cpp("Instruction", "", instructions)


print('}', file=file)
print('}', file=fwd_file)
file.close()
fwd_file.close()

# run clang-format
os.system('clang-format -i ir_v2_defs.h')
os.system('clang-format -i ir_v2_fwd.h')
