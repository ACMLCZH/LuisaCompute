#pragma pack_matrix(row_major)
#define INFINITY_f (1.#INF)
SamplerState samplers[16]:register(s0,space1);
template<typename T>
T _acosh(T v){return log(v+sqrt(v*v-1.0));}
template<typename T>
T _asinh(T v){return log(v+sqrt(v*v+1.0));}
template<typename T>
T _atanh(T v){return 0.5*log((1.0+v)/(1.0-v));}
template<typename T>
T _exp10(T v){return pow(10,v);};
template<typename T>
float _length_sqr(T x){return dot(x,x);}
float copysign(float a,float b){return asfloat((asuint(a)&0x7fffffffu) | (asuint(b)&0x80000000u));}
float2 copysign(float2 a,float2 b){return asfloat((asuint(a)&0x7fffffffu) | (asuint(b)&0x80000000u));}
float3 copysign(float3 a,float3 b){return asfloat((asuint(a)&0x7fffffffu) | (asuint(b)&0x80000000u));}
float4 copysign(float4 a,float4 b){return asfloat((asuint(a)&0x7fffffffu) | (asuint(b)&0x80000000u));}
float16_t copysign(float16_t a,float16_t b){return copysign((float)a,(float)b);}
float16_t copysign(float16_t2 a,float16_t2 b){return copysign((float2)a,(float2)b);}
float16_t copysign(float16_t3 a,float16_t3 b){return copysign((float3)a,(float3)b);}
float16_t copysign(float16_t4 a,float16_t4 b){return copysign((float4)a,(float4)b);}
template<typename T>
T _fma(T a,T b,T c){return a*b+c;}
// TODO
float2x2 _float2x2(float3x4 v){return float2x2(v[0].xy,v[1].xy);}
float2x2 _float2x2(float4x4 v){return float2x2(v[0].xy,v[1].xy);}
float3x4 _float3x3(float2x2 v){return float3x4(v[0],0,0,v[1],0,0,0,0,0,0);}
float3x4 _float3x3(float4x4 v){return float3x4(v[0].xyz,0,v[1].xyz,0,v[2].xyz,0);}
float4x4 _float4x4(float2x2 v){return float4x4(v[0],0,0,v[1].xy,0,0,0,0,0,0,0,0,0,0);};
float4x4 _float4x4(float3x4 v){return float4x4(v[0].xyz,0,v[1].xyz,0,v[2].xyz,0,0,0,0,0);}
float2x2 _float2x2(float m00,float m01,float m10,float m11){return float2x2(m00,m01,m10,m11);}
float3x4 _float3x3(float m00,float m01,float m02,float m10,float m11,float m12,float m20,float m21,float m22){return float3x4(m00,m01,m02,0,m10,m11,m12,0,m20,m21,m22,0);}
float4x4 _float4x4(float m00,float m01,float m02,float m03,float m10,float m11,float m12,float m13,float m20,float m21,float m22,float m23,float m30,float m31,float m32,float m33){return float4x4(m00,m01,m02,m03,m10,m11,m12,m13,m20,m21,m22,m23,m30,m31,m32,m33);}
float2x2 _float2x2(float2 c0,float2 c1){return float2x2(c0,c1);}
float3x4 _float3x3(float3 c0,float3 c1,float3 c2){return float3x4(float4(c0,0),float4(c1,0),float4(c2,0));}
float4x4 _float4x4(float4 c0,float4 c1,float4 c2,float4 c3){return float4x4(c0,c1,c2,c3);}
float2x2 _transpose(float2x2 m){return transpose(m);}
float3x4 _transpose(float3x4 m){
float4x3 mm=transpose(m);
return _float3x3(mm[0],mm[1],mm[2]);
}
float4x4 _transpose(float4x4 m){return transpose(m);}
float4x4 Mul(float4x4 a,float4x4 b){return mul(a,b);}
float3x4 Mul(float3x4 a,float3x4 b){return mul(a,float4x4(b,0,0,0,0));}
float2x2 Mul(float2x2 a,float2x2 b){return mul(a,b);}
float4 Mul(float4x4 b,float4 a){return mul(a,b);}
float3 Mul(float3x4 b,float3 a){return mul(a,b).xyz;}
float2 Mul(float2x2 b,float2 a){return mul(a,b);}
float16_t4 Mul(float16_t4x4 b,float16_t4 a){return mul(a,b);}
float16_t3 Mul(float16_t3x4 b,float16_t3 a){return mul(a,b).xyz;}
float16_t2 Mul(float16_t2x2 b,float16_t2 a){return mul(a,b);}
struct wbool3 {bool3 v; bool a;};
struct wfloat3 {float3 v; float a;};
struct wuint3 {uint3 v; uint a;};
struct wint3 {int3 v; int a;};
struct WrappedFloat2x2 {row_major float2x2 m;};
struct WrappedFloat3x3 {
row_major float3x4 m;
};
struct WrappedFloat4x4 {
row_major float4x4 m;
};
#define bfread(bf,idx) bf[idx]
#define bfreadVec3(bf,idx) bf[idx].xyz
#define bfreadMat(bf,idx) bf[idx].m
#define bfwrite(bf,idx,value) bf[idx]=value
#define bfwriteVec3(bf,idx,value) bf[idx]=float4(value,0)
#define bfwriteMat(bf,idx,value) bf[idx].m=value
#define Smptx(tex,uv) tex[uv]
#define Writetx(tex,uv,value) tex[uv]=value
uint ReadBdlsBuffer(ByteAddressBuffer s,uint idx){
return s.Load(16*idx);
}
template<typename T>
T fract(T x){return x-floor(x);}
#define READ_BUFFER(arr,arrIdx,idx,size,type,bf) bf[NonUniformResourceIndex(ReadBdlsBuffer(arr,arrIdx))].Load<type>(size*idx)
template<typename T>
uint bdlsBfSize(ByteAddressBuffer arr,uint arrIdx,uint size,T bf){
uint sz;
bf[NonUniformResourceIndex(ReadBdlsBuffer(arr,arrIdx))].GetDimensions(sz);
return sz/size;
}
struct MeshInst {
float4 p0;
float4 p1;
float4 p2;
uint InstanceID:24;
uint InstanceMask:8;
uint InstanceContributionToHitGroupIndex:24;
uint Flags:8;
uint2 accelStructPtr;
};
template<typename T>
float4x4 InstMatrix(T instBuffer,uint index){
MeshInst v=instBuffer[index];
return float4x4(
float4(v.p0.x,v.p1.x,v.p2.x,0),
float4(v.p0.y,v.p1.y,v.p2.y,0),
float4(v.p0.z,v.p1.z,v.p2.z,0),
float4(v.p0.w,v.p1.w,v.p2.w,1));
}
void SetInstTransform(inout MeshInst i,float4x4 mat){
i.p0=float4(mat[0].x,mat[1].x,mat[2].x,mat[3].x);
i.p1=float4(mat[0].y,mat[1].y,mat[2].y,mat[3].y);
i.p2=float4(mat[0].z,mat[1].z,mat[2].z,mat[3].z);
}
void SetAccelTransform(RWStructuredBuffer<MeshInst> buffer,uint index,float4x4 mat){
SetInstTransform(buffer[index],mat);
}
void SetAccelVis(RWStructuredBuffer<MeshInst> buffer,uint index,uint mask){
buffer[index].InstanceMask=mask;
}
void SetAccelOpaque(RWStructuredBuffer<MeshInst> buffer,uint index,bool opaque){
buffer[index].Flags=select(opaque,4,8);
}
struct Hit0{uint v0;uint v1;float2 v2;uint v3;float v4;};
struct Hit1{uint v0;uint v1;float2 v2;float v3;};
struct Hit2{uint v0;uint v1;};
template<typename T>
uint bfsize(T b){
uint c,s;
b.GetDimensions(c,s);
return c;
}
uint2 texsize(Texture2D<float4> t){
uint2 s;
uint mip;
t.GetDimensions(0,s.x,s.y,mip);
return s;
}
uint2 texsize(Texture2D<uint4> t){
uint2 s;
uint mip;
t.GetDimensions(0,s.x,s.y,mip);
return s;
}
uint2 texsize(Texture2D<int4> t){
uint2 s;
uint mip;
t.GetDimensions(0,s.x,s.y,mip);
return s;
}
uint3 texsize(Texture3D<float4> t){
uint3 s;
uint mip;
t.GetDimensions(0,s.x,s.y,s.z,mip);
return s;
}
uint3 texsize(Texture3D<uint4> t){
uint3 s;
uint mip;
t.GetDimensions(0,s.x,s.y,s.z,mip);
return s;
}
uint3 texsize(Texture3D<int4> t){
uint3 s;
uint mip;
t.GetDimensions(0,s.x,s.y,s.z,mip);
return s;
}
