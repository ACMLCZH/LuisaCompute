#pragma pack_matrix(row_major)
#define INFINITY_f (1.#INF)
#define LC_IndirectKernelDispatch uint
SamplerState samplers[16]:register(s0,space1);
float determinant(const float2x2 m){
return m[0][0]*m[1][1]-m[1][0]*m[0][1];
}
float determinant(const float3x4 m){
return m[0].x*(m[1].y*m[2].z-m[2].y*m[1].z)-m[1].x*(m[0].y*m[2].z-m[2].y*m[0].z)+m[2].x*(m[0].y*m[1].z-m[1].y*m[0].z);
}
float determinant(const float4x4 m){
const float coef00=m[2].z*m[3].w-m[3].z*m[2].w;
const float coef02=m[1].z*m[3].w-m[3].z*m[1].w;
const float coef03=m[1].z*m[2].w-m[2].z*m[1].w;
const float coef04=m[2].y*m[3].w-m[3].y*m[2].w;
const float coef06=m[1].y*m[3].w-m[3].y*m[1].w;
const float coef07=m[1].y*m[2].w-m[2].y*m[1].w;
const float coef08=m[2].y*m[3].z-m[3].y*m[2].z;
const float coef10=m[1].y*m[3].z-m[3].y*m[1].z;
const float coef11=m[1].y*m[2].z-m[2].y*m[1].z;
const float coef12=m[2].x*m[3].w-m[3].x*m[2].w;
const float coef14=m[1].x*m[3].w-m[3].x*m[1].w;
const float coef15=m[1].x*m[2].w-m[2].x*m[1].w;
const float coef16=m[2].x*m[3].z-m[3].x*m[2].z;
const float coef18=m[1].x*m[3].z-m[3].x*m[1].z;
const float coef19=m[1].x*m[2].z-m[2].x*m[1].z;
const float coef20=m[2].x*m[3].y-m[3].x*m[2].y;
const float coef22=m[1].x*m[3].y-m[3].x*m[1].y;
const float coef23=m[1].x*m[2].y-m[2].x*m[1].y;
const float4 fac0=float4(coef00,coef00,coef02,coef03);
const float4 fac1=float4(coef04,coef04,coef06,coef07);
const float4 fac2=float4(coef08,coef08,coef10,coef11);
const float4 fac3=float4(coef12,coef12,coef14,coef15);
const float4 fac4=float4(coef16,coef16,coef18,coef19);
const float4 fac5=float4(coef20,coef20,coef22,coef23);
const float4 Vec0=float4(m[1].x,m[0].x,m[0].x,m[0].x);
const float4 Vec1=float4(m[1].y,m[0].y,m[0].y,m[0].y);
const float4 Vec2=float4(m[1].z,m[0].z,m[0].z,m[0].z);
const float4 Vec3=float4(m[1].w,m[0].w,m[0].w,m[0].w);
const float4 inv0=Vec1*fac0-Vec2*fac1+Vec3*fac2;
const float4 inv1=Vec0*fac0-Vec2*fac3+Vec3*fac4;
const float4 inv2=Vec0*fac1-Vec1*fac3+Vec3*fac5;
const float4 inv3=Vec0*fac2-Vec1*fac4+Vec2*fac5;
const float4 sign_a=float4(+1.0f,-1.0f,+1.0f,-1.0f);
const float4 sign_b=float4(-1.0f,+1.0f,-1.0f,+1.0f);
const float4 inv_0=inv0*sign_a;
const float4 inv_1=inv1*sign_b;
const float4 inv_2=inv2*sign_a;
const float4 inv_3=inv3*sign_b;
const float4 dot0=m[0]*float4(inv_0.x,inv_1.x,inv_2.x,inv_3.x);
return dot0.x+dot0.y+dot0.z+dot0.w;
}
float2x2 inverse(const float2x2 m){
const float one_over_determinant=1.0f/(m[0][0]*m[1][1]-m[1][0]*m[0][1]);
return float2x2(m[1][1]*one_over_determinant,
-m[0][1]*one_over_determinant,
-m[1][0]*one_over_determinant,
+m[0][0]*one_over_determinant);
}
float3x4 inverse(const float3x4 m){
const float one_over_determinant=1.0f /
(m[0].x*(m[1].y*m[2].z-m[2].y*m[1].z) -
m[1].x*(m[0].y*m[2].z-m[2].y*m[0].z) +
m[2].x*(m[0].y*m[1].z-m[1].y*m[0].z));
return float3x4(
(m[1].y*m[2].z-m[2].y*m[1].z)*one_over_determinant,
(m[2].y*m[0].z-m[0].y*m[2].z)*one_over_determinant,
(m[0].y*m[1].z-m[1].y*m[0].z)*one_over_determinant,
0,
(m[2].x*m[1].z-m[1].x*m[2].z)*one_over_determinant,
(m[0].x*m[2].z-m[2].x*m[0].z)*one_over_determinant,
(m[1].x*m[0].z-m[0].x*m[1].z)*one_over_determinant,
0,
(m[1].x*m[2].y-m[2].x*m[1].y)*one_over_determinant,
(m[2].x*m[0].y-m[0].x*m[2].y)*one_over_determinant,
(m[0].x*m[1].y-m[1].x*m[0].y)*one_over_determinant,
0);
}
float4x4 inverse(const float4x4 m){
const float coef00=m[2].z*m[3].w-m[3].z*m[2].w;
const float coef02=m[1].z*m[3].w-m[3].z*m[1].w;
const float coef03=m[1].z*m[2].w-m[2].z*m[1].w;
const float coef04=m[2].y*m[3].w-m[3].y*m[2].w;
const float coef06=m[1].y*m[3].w-m[3].y*m[1].w;
const float coef07=m[1].y*m[2].w-m[2].y*m[1].w;
const float coef08=m[2].y*m[3].z-m[3].y*m[2].z;
const float coef10=m[1].y*m[3].z-m[3].y*m[1].z;
const float coef11=m[1].y*m[2].z-m[2].y*m[1].z;
const float coef12=m[2].x*m[3].w-m[3].x*m[2].w;
const float coef14=m[1].x*m[3].w-m[3].x*m[1].w;
const float coef15=m[1].x*m[2].w-m[2].x*m[1].w;
const float coef16=m[2].x*m[3].z-m[3].x*m[2].z;
const float coef18=m[1].x*m[3].z-m[3].x*m[1].z;
const float coef19=m[1].x*m[2].z-m[2].x*m[1].z;
const float coef20=m[2].x*m[3].y-m[3].x*m[2].y;
const float coef22=m[1].x*m[3].y-m[3].x*m[1].y;
const float coef23=m[1].x*m[2].y-m[2].x*m[1].y;
const float4 fac0=float4(coef00,coef00,coef02,coef03);
const float4 fac1=float4(coef04,coef04,coef06,coef07);
const float4 fac2=float4(coef08,coef08,coef10,coef11);
const float4 fac3=float4(coef12,coef12,coef14,coef15);
const float4 fac4=float4(coef16,coef16,coef18,coef19);
const float4 fac5=float4(coef20,coef20,coef22,coef23);
const float4 Vec0=float4(m[1].x,m[0].x,m[0].x,m[0].x);
const float4 Vec1=float4(m[1].y,m[0].y,m[0].y,m[0].y);
const float4 Vec2=float4(m[1].z,m[0].z,m[0].z,m[0].z);
const float4 Vec3=float4(m[1].w,m[0].w,m[0].w,m[0].w);
const float4 inv0=Vec1*fac0-Vec2*fac1+Vec3*fac2;
const float4 inv1=Vec0*fac0-Vec2*fac3+Vec3*fac4;
const float4 inv2=Vec0*fac1-Vec1*fac3+Vec3*fac5;
const float4 inv3=Vec0*fac2-Vec1*fac4+Vec2*fac5;
const float4 sign_a=float4(+1.0f,-1.0f,+1.0f,-1.0f);
const float4 sign_b=float4(-1.0f,+1.0f,-1.0f,+1.0f);
const float4 inv_0=inv0*sign_a;
const float4 inv_1=inv1*sign_b;
const float4 inv_2=inv2*sign_a;
const float4 inv_3=inv3*sign_b;
const float4 dot0=m[0]*float4(inv_0.x,inv_1.x,inv_2.x,inv_3.x);
const float dot1=dot0.x+dot0.y+dot0.z+dot0.w;
const float one_over_determinant=1.0f/dot1;
return float4x4(inv_0*one_over_determinant,
inv_1*one_over_determinant,
inv_2*one_over_determinant,
inv_3*one_over_determinant);
}
template<typename T>
T _acosh(const T v){return log(v+sqrt(v*v-1.0));}
template<typename T>
T _asinh(const T v){return log(v+sqrt(v*v+1.0));}
template<typename T>
T _atanh(const T v){return 0.5*log((1.0+v)/(1.0-v));}
template<typename T>
T _exp10(const T v){return pow(10,v);};
template<typename T>
float _length_sqr(const T x){return dot(x,x);}
float copysign(const float a,const float b){return asfloat((asuint(a)&0x7fffffffu) | (asuint(b)&0x80000000u));}
float2 copysign(const float2 a,const float2 b){return asfloat((asuint(a)&0x7fffffffu) | (asuint(b)&0x80000000u));}
float3 copysign(const float3 a,const float3 b){return asfloat((asuint(a)&0x7fffffffu) | (asuint(b)&0x80000000u));}
float4 copysign(const float4 a,const float4 b){return asfloat((asuint(a)&0x7fffffffu) | (asuint(b)&0x80000000u));}
float16_t copysign(const float16_t a,const float16_t b){return copysign((float)a,(float)b);}
float16_t copysign(const float16_t2 a,const float16_t2 b){return copysign((float2)a,(float2)b);}
float16_t copysign(const float16_t3 a,const float16_t3 b){return copysign((float3)a,(float3)b);}
float16_t copysign(const float16_t4 a,const float16_t4 b){return copysign((float4)a,(float4)b);}
template<typename T>
T _fma(const T a,const T b,const T c){return a*b+c;}
// TODO
float2x2 _float2x2(const float3x4 v){return float2x2(v[0].xy,v[1].xy);}
float2x2 _float2x2(const float4x4 v){return float2x2(v[0].xy,v[1].xy);}
float3x4 _float3x3(const float2x2 v){return float3x4(v[0],0,0,v[1],0,0,0,0,0,0);}
float3x4 _float3x3(const float4x4 v){return float3x4(v[0].xyz,0,v[1].xyz,0,v[2].xyz,0);}
float4x4 _float4x4(const float2x2 v){return float4x4(v[0],0,0,v[1].xy,0,0,0,0,0,0,0,0,0,0);};
float4x4 _float4x4(const float3x4 v){return float4x4(v[0].xyz,0,v[1].xyz,0,v[2].xyz,0,0,0,0,0);}
float2x2 _float2x2(const float m00,const float m01,const float m10,const float m11){return float2x2(m00,m01,m10,m11);}
float3x4 _float3x3(const float m00,const float m01,const float m02,const float m10,const float m11,const float m12,const float m20,const float m21,const float m22){return float3x4(m00,m01,m02,0,m10,m11,m12,0,m20,m21,m22,0);}
float4x4 _float4x4(const float m00,const float m01,const float m02,const float m03,const float m10,const float m11,const float m12,const float m13,const float m20,const float m21,const float m22,const float m23,const float m30,const float m31,const float m32,const float m33){return float4x4(m00,m01,m02,m03,m10,m11,m12,m13,m20,m21,m22,m23,m30,m31,m32,m33);}
float2x2 _float2x2(const float2 c0,const float2 c1){return float2x2(c0,c1);}
float3x4 _float3x3(const float3 c0,const float3 c1,const float3 c2){return float3x4(float4(c0,0),float4(c1,0),float4(c2,0));}
float4x4 _float4x4(const float4 c0,const float4 c1,const float4 c2,const float4 c3){return float4x4(c0,c1,c2,c3);}
float2x2 _transpose(const float2x2 m){return transpose(m);}
float3x4 _transpose(const float3x4 m){
const float4x3 mm=transpose(m);
return _float3x3(mm[0],mm[1],mm[2]);
}
float4x4 _transpose(const float4x4 m){return transpose(m);}
float4x4 Mul(const float4x4 a,const float4x4 b){return mul(a,b);}
float3x4 Mul(const float3x4 a,const float3x4 b){return mul(a,float4x4(b,0,0,0,0));}
float2x2 Mul(const float2x2 a,const float2x2 b){return mul(a,b);}
float4 Mul(const float4x4 b,const float4 a){return mul(a,b);}
float3 Mul(const float3x4 b,const float3 a){return mul(a,b).xyz;}
float2 Mul(const float2x2 b,const float2 a){return mul(a,b);}
float16_t4 Mul(const float16_t4x4 b,const float16_t4 a){return mul(a,b);}
float16_t3 Mul(const float16_t3x4 b,const float16_t3 a){return mul(a,b).xyz;}
float16_t2 Mul(const float16_t2x2 b,const float16_t2 a){return mul(a,b);}
struct wbool3 {bool3 v; bool a;};
struct wfloat3 {float3 v; float a;};
struct wuint3 {uint3 v; uint a;};
struct wint3 {int3 v; int a;};
struct WrappedFloat2x2 {row_major float2x2 m;};
struct WrappedFloat3x3 {
row_major float3x4 m;
};
struct WrappedFloat4x4 {
row_major float4x4 m;
};
#define bfread(bf,idx) bf[idx]
#define bfreadVec3(bf,idx) bf[idx].xyz
#define bfreadMat(bf,idx) bf[idx].m
#define bfwrite(bf,idx,value) bf[idx]=value
#define bfwriteVec3(bf,idx,value) bf[idx]=float4(value,0)
#define bfwriteMat(bf,idx,value) bf[idx].m=value
#define Smptx(tex,uv) tex[uv]
#define Writetx(tex,uv,value) tex[uv]=value
uint ReadBdlsBuffer(const ByteAddressBuffer s,const uint idx){
return s.Load(24*idx);
}
uint ReadBdlsTex2D(const ByteAddressBuffer s,const uint idx){
return s.Load(24*idx+4);
}
uint ReadBdlsTex3D(const ByteAddressBuffer s,const uint idx){
return s.Load(24*idx+8);
}
uint2 ReadBdlsTex2DXY(const ByteAddressBuffer s,const uint idx){
uint xy=s.Load(24*idx+12);
uint x=(xy>>16);
uint y=(xy&65535);
return uint2(x,y);
}
uint3 ReadBdlsTex3DXYZ(const ByteAddressBuffer s,const uint idx){
uint xy=s.Load(24*idx+16);
uint smp=s.Load(24*idx+20);
uint x=(xy>>16);
uint y=(xy&65535);
uint z=(smp>>16);
return uint3(x,y,z);
}
uint ReadBdlsSmp3D(const ByteAddressBuffer s,const uint idx){
uint smp=s.Load(24*idx+20);
smp=(smp>>8);
return smp&255;
}
uint ReadBdlsSmp2D(const ByteAddressBuffer s,const uint idx){
uint smp=s.Load(24*idx+20);
return smp&255;
}
template<typename T>
T fract(const T x){return x-floor(x);}
#define READ_BUFFER(arr,arrIdx,idx,size,type,bf) bf[NonUniformResourceIndex(ReadBdlsBuffer(arr,arrIdx))].Load<type>(size*idx)
struct MeshInst {
float4 p0;
float4 p1;
float4 p2;
uint InstanceID:24;
uint InstanceMask:8;
uint InstanceContributionToHitGroupIndex:24;
uint Flags:8;
uint2 accelStructPtr;
};
template<typename T,typename Idx>
float4x4 InstMatrix(const T instBuffer,const Idx index){
MeshInst v=instBuffer[index];
return float4x4(
float4(v.p0.x,v.p1.x,v.p2.x,0),
float4(v.p0.y,v.p1.y,v.p2.y,0),
float4(v.p0.z,v.p1.z,v.p2.z,0),
float4(v.p0.w,v.p1.w,v.p2.w,1));
}
void SetInstTransform(inout MeshInst i,const float4x4 mat){
i.p0=float4(mat[0].x,mat[1].x,mat[2].x,mat[3].x);
i.p1=float4(mat[0].y,mat[1].y,mat[2].y,mat[3].y);
i.p2=float4(mat[0].z,mat[1].z,mat[2].z,mat[3].z);
}
template<typename Idx>
void SetAccelTransform(RWStructuredBuffer<MeshInst> buffer,const Idx index,const float4x4 mat){
SetInstTransform(buffer[index],mat);
}
template<typename Idx>
void SetAccelVis(RWStructuredBuffer<MeshInst> buffer,const Idx index,const uint mask){
buffer[index].InstanceMask=mask;
}
template<typename Idx>
void SetAccelOpaque(RWStructuredBuffer<MeshInst> buffer,const Idx index,const bool opaque){
buffer[index].Flags=select(opaque,4,8);
}
struct Hit0{uint v0;uint v1;float2 v2;uint v3;float v4;};
struct Hit1{uint v0;uint v1;float2 v2;float v3;};
struct Hit2{uint v0;uint v1;};
void ClearDispInd(RWStructuredBuffer<uint> buffer){buffer[0]=0;}
void EmplaceDispInd3D(RWStructuredBuffer<uint> buffer,const uint3 blk,const uint3 size,const uint ker){
uint idx;
uint3 dispSize=(size+blk-1)/blk;
InterlockedAdd(buffer[0],1,idx);
idx=idx*7+1;
buffer[idx]=size.x;
buffer[idx+1]=size.y;
buffer[idx+2]=size.z;
buffer[idx+3]=ker;
buffer[idx+4]=dispSize.x;
buffer[idx+5]=dispSize.y;
buffer[idx+6]=dispSize.z;
}
void EmplaceDispInd2D(RWStructuredBuffer<uint> buffer,const uint2 blk,const uint2 size,const uint ker){
uint idx;
uint2 dispSize=(size+blk-1)/blk;
InterlockedAdd(buffer[0],1,idx);
idx=idx*7+1;
buffer[idx]=size.x;
buffer[idx+1]=size.y;
buffer[idx+2]=1;
buffer[idx+3]=ker;
buffer[idx+4]=dispSize.x;
buffer[idx+5]=dispSize.y;
buffer[idx+6]=1;
}
void EmplaceDispInd1D(RWStructuredBuffer<uint> buffer,const uint blk,const uint size,const uint ker){
uint idx;
uint dispSize=(size+blk-1)/blk;
InterlockedAdd(buffer[0],1,idx);
idx=idx*7+1;
buffer[idx]=size;
buffer[idx+1]=1;
buffer[idx+2]=1;
buffer[idx+3]=ker;
buffer[idx+4]=dispSize;
buffer[idx+5]=1;
buffer[idx+6]=1;
}
