#define CLOSEST_HIT_RAY_FLAG (RAY_FLAG_FORCE_OPAQUE | RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES)
#define ANY_HIT_RAY_FLAG (RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER | RAY_FLAG_FORCE_OPAQUE | RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES)
typedef RayQuery<RAY_FLAG_NONE> LC_RayQueryAll;
typedef RayQuery<RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH> LC_RayQueryAny;
template<typename T>
Hit1 TraceClosest(RaytracingAccelerationStructure accel,T rayDesc,uint mask){
RayDesc ray;
ray.Origin=float3(rayDesc.v0.v[0],rayDesc.v0.v[1],rayDesc.v0.v[2]);
ray.Direction=float3(rayDesc.v2.v[0],rayDesc.v2.v[1],rayDesc.v2.v[2]);
ray.TMin=rayDesc.v1;
ray.TMax=rayDesc.v3;
RayQuery<CLOSEST_HIT_RAY_FLAG> q;
q.TraceRayInline(accel,CLOSEST_HIT_RAY_FLAG,mask,ray);
Hit1 pl;
q.Proceed();
if(q.CommittedStatus()==COMMITTED_TRIANGLE_HIT){
pl.v0=q.CommittedInstanceIndex();
pl.v1=q.CommittedPrimitiveIndex();
pl.v2=q.CommittedTriangleBarycentrics();
pl.v3=q.CommittedRayT();
}else{
pl.v0=4294967295;
}
return pl;
}
template<typename T>
LC_RayQueryAll QueryAll(RaytracingAccelerationStructure accel,T rayDesc,uint mask){
RayDesc ray;
ray.Origin=float3(rayDesc.v0.v[0],rayDesc.v0.v[1],rayDesc.v0.v[2]);
ray.Direction=float3(rayDesc.v2.v[0],rayDesc.v2.v[1],rayDesc.v2.v[2]);
ray.TMin=rayDesc.v1;
ray.TMax=rayDesc.v3;
LC_RayQueryAll q;
q.TraceRayInline(accel,RAY_FLAG_NONE,mask,ray);
return q;
}
template<typename T>
LC_RayQueryAny QueryAny(RaytracingAccelerationStructure accel,T rayDesc,uint mask){
RayDesc ray;
ray.Origin=float3(rayDesc.v0.v[0],rayDesc.v0.v[1],rayDesc.v0.v[2]);
ray.Direction=float3(rayDesc.v2.v[0],rayDesc.v2.v[1],rayDesc.v2.v[2]);
ray.TMin=rayDesc.v1;
ray.TMax=rayDesc.v3;
LC_RayQueryAny q;
q.TraceRayInline(accel,RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH,mask,ray);
return q;
}

template<typename T, typename Q>
T RayQueryGetWorldRay(Q q) {
  float3 o = q.WorldRayOrigin();
  float3 d = q.WorldRayDirection();
  float t_min = q.RayTMin();
  float t_max = q.CommittedRayT();
  T ray;
  ray.v0.v[0] = o.x;
  ray.v0.v[1] = o.y;
  ray.v0.v[2] = o.z;
  ray.v1 = t_min;
  ray.v2.v[0] = d.x;
  ray.v2.v[1] = d.y;
  ray.v2.v[2] = d.z;
  ray.v3 = t_max;
  return ray;
}

template<typename T, typename Q>
T RayQueryGetObjectRay(Q q) {
  float3 o = q.ObjectRayOrigin();
  float3 d = q.ObjectRayDirection();
  float t_min = q.RayTMin();
  float t_max = q.CommittedRayT();
  T ray;
  ray.v0.v[0] = o.x;
  ray.v0.v[1] = o.y;
  ray.v0.v[2] = o.z;
  ray.v1 = t_min;
  ray.v2.v[0] = d.x;
  ray.v2.v[1] = d.y;
  ray.v2.v[2] = d.z;
  ray.v3 = t_max;
  return ray;
}

template<typename Q>
Hit0 GetCommitedHit(const Q q){
Hit0 pl;
switch(q.CommittedStatus()){
case COMMITTED_TRIANGLE_HIT:
pl.v0=q.CommittedInstanceIndex();
pl.v1=q.CommittedPrimitiveIndex();
pl.v2=q.CommittedTriangleBarycentrics();
pl.v3=1;
pl.v4=q.CommittedRayT();
break;
case COMMITTED_PROCEDURAL_PRIMITIVE_HIT:
pl.v0=q.CommittedInstanceIndex();
pl.v1=q.CommittedPrimitiveIndex();
pl.v2=0;
pl.v3=2;
pl.v4=q.CommittedRayT();
break;
default:
pl.v3=0;
break;
}
return pl;
}
template<typename Q>
Hit1 GetTriangleCandidateHit(const Q q){
Hit1 pl;
pl.v0=q.CandidateInstanceIndex();
pl.v1=q.CandidatePrimitiveIndex();
pl.v2=q.CandidateTriangleBarycentrics();
pl.v3=q.CandidateTriangleRayT();
return pl;
}
template<typename Q>
Hit2 GetProceduralCandidateHit(const Q q){
Hit2 pl;
pl.v0=q.CandidateInstanceIndex();
pl.v1=q.CandidatePrimitiveIndex();
return pl;
}
#define LCRayQueryGetRay(q) q_ray
template<typename T>
bool TraceAny(RaytracingAccelerationStructure accel,T rayDesc,uint mask){
RayDesc ray;
ray.Origin=float3(rayDesc.v0.v[0],rayDesc.v0.v[1],rayDesc.v0.v[2]);
ray.Direction=float3(rayDesc.v2.v[0],rayDesc.v2.v[1],rayDesc.v2.v[2]);
ray.TMin=rayDesc.v1;
ray.TMax=rayDesc.v3;
RayQuery<ANY_HIT_RAY_FLAG> q;
q.TraceRayInline(accel,ANY_HIT_RAY_FLAG,mask,ray);
q.Proceed();
return q.CommittedStatus()!=COMMITTED_NOTHING;
}
