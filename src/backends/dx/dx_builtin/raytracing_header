#define CLOSEST_HIT_RAY_FLAG (RAY_FLAG_FORCE_OPAQUE | RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES)
#define ALL_HIT_RAY_FLAG (RAY_FLAG_NONE)
#define ANY_HIT_RAY_FLAG (RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER | RAY_FLAG_FORCE_OPAQUE | RAY_FLAG_SKIP_PROCEDURAL_PRIMITIVES)
template<typename T>
RayPayload TraceClosest(RaytracingAccelerationStructure accel,T rayDesc){
RayDesc ray;
ray.Origin=float3(rayDesc.v0.v[0],rayDesc.v0.v[1],rayDesc.v0.v[2]);
ray.Direction=float3(rayDesc.v2.v[0],rayDesc.v2.v[1],rayDesc.v2.v[2]);
ray.TMin=rayDesc.v1;
ray.TMax=rayDesc.v3;
RayQuery<CLOSEST_HIT_RAY_FLAG> q;
q.TraceRayInline(accel,CLOSEST_HIT_RAY_FLAG,~0,ray);
RayPayload pl;
q.Proceed();
if(q.CommittedStatus()==COMMITTED_TRIANGLE_HIT){
pl.v0=q.CommittedInstanceIndex();
pl.v1=q.CommittedPrimitiveIndex();
pl.v2=q.CommittedTriangleBarycentrics();
pl.v3=1;
pl.v4=q.CommittedRayT();
}else{
pl.v3=0;
}
return pl;
}
template<typename T>
RayQuery<ALL_HIT_RAY_FLAG> TraceAll(RaytracingAccelerationStructure accel,T rayDesc){
RayDesc ray;
ray.Origin=float3(rayDesc.v0.v[0],rayDesc.v0.v[1],rayDesc.v0.v[2])  ;
ray.Direction=float3(rayDesc.v2.v[0],rayDesc.v2.v[1],rayDesc.v2.v[2]);
ray.TMin=rayDesc.v1;
ray.TMax=rayDesc.v3;
RayQuery<ALL_HIT_RAY_FLAG> q;
q.TraceRayInline(accel,ALL_HIT_RAY_FLAG,~0,ray);
return q;
}
RayPayload GetCommitedHit(const RayQuery<ALL_HIT_RAY_FLAG> q){
RayPayload pl;
switch(q.CommittedStatus()){
case COMMITTED_TRIANGLE_HIT:
pl.v0=q.CommittedInstanceIndex();
pl.v1=q.CommittedPrimitiveIndex();
pl.v2=q.CommittedTriangleBarycentrics();
pl.v3=1;
pl.v4=q.CommittedRayT();
break;
case COMMITTED_PROCEDURAL_PRIMITIVE_HIT:
pl.v0=q.CommittedInstanceIndex();
pl.v1=q.CommittedPrimitiveIndex();
pl.v2=0;
pl.v3=2;
pl.v4=q.CommittedRayT();
break;
default:
pl.v3=0;
break;
}
return pl;
}
RayPayload GetTriangleCandidateHit(const RayQuery<ALL_HIT_RAY_FLAG> q){
RayPayload pl;
pl.v0=q.CandidateInstanceIndex();
pl.v1=q.CandidatePrimitiveIndex();
pl.v2=q.CandidateTriangleBarycentrics();
pl.v3=1;
pl.v4=q.CandidateTriangleRayT();
return pl;
}
RayPayload GetProceduralCandidateHit(const RayQuery<ALL_HIT_RAY_FLAG> q){
RayPayload pl;
pl.v0=q.CandidateInstanceIndex();
pl.v1=q.CandidatePrimitiveIndex();
pl.v2=0;
pl.v3=2;
pl.v4=0;
return pl;
}
template<typename T>
bool TraceAny(RaytracingAccelerationStructure accel,T rayDesc){
RayDesc ray;
ray.Origin=float3(rayDesc.v0.v[0],rayDesc.v0.v[1],rayDesc.v0.v[2]);
ray.Direction=float3(rayDesc.v2.v[0],rayDesc.v2.v[1],rayDesc.v2.v[2]);
ray.TMin=rayDesc.v1;
ray.TMax=rayDesc.v3;
RayQuery<ANY_HIT_RAY_FLAG> q;
q.TraceRayInline(accel,ANY_HIT_RAY_FLAG,~0,ray);
q.Proceed();
return q.CommittedStatus()!=COMMITTED_NOTHING;
}
