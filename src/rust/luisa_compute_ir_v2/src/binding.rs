/* automatically generated by rust-bindgen 0.68.1 */

pub const _STL_COMPILER_PREPROCESSOR: u32 = 1;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const NULL: u32 = 0;
pub const _HAS_CXX17: u32 = 1;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 1;
pub const _STL_WARNING_LEVEL: u32 = 3;
pub const _STL_DISABLED_WARNING_C5053: u32 = 5053;
pub const _CPPLIB_VER: u32 = 650;
pub const _MSVC_STL_VERSION: u32 = 143;
pub const _MSVC_STL_UPDATE: u32 = 202305;
pub const _HAS_STATIC_RTTI: u32 = 1;
pub const _HAS_STD_BYTE: u32 = 1;
pub const _ENFORCE_MATCHING_ALLOCATORS: u32 = 1;
pub const _ENFORCE_FACET_SPECIALIZATIONS: u32 = 0;
pub const _FACET_SPECIALIZATION_MESSAGE : & [u8 ; 167] = b"Unsupported facet specialization; see N4950 [locale.category]. Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 to suppress this error.\0" ;
pub const _STL_OPTIMIZE_SYSTEM_ERROR_OPERATORS: u32 = 1;
pub const _STD_VECTORIZE_WITH_FLOAT_CONTROL: u32 = 1;
pub const __cpp_lib_chrono_udls: u32 = 201304;
pub const __cpp_lib_complex_udls: u32 = 201309;
pub const __cpp_lib_exchange_function: u32 = 201304;
pub const __cpp_lib_generic_associative_lookup: u32 = 201304;
pub const __cpp_lib_integer_sequence: u32 = 201304;
pub const __cpp_lib_integral_constant_callable: u32 = 201304;
pub const __cpp_lib_is_final: u32 = 201402;
pub const __cpp_lib_is_null_pointer: u32 = 201309;
pub const __cpp_lib_make_reverse_iterator: u32 = 201402;
pub const __cpp_lib_make_unique: u32 = 201304;
pub const __cpp_lib_null_iterators: u32 = 201304;
pub const __cpp_lib_quoted_string_io: u32 = 201304;
pub const __cpp_lib_result_of_sfinae: u32 = 201210;
pub const __cpp_lib_robust_nonmodifying_seq_ops: u32 = 201304;
pub const __cpp_lib_shared_timed_mutex: u32 = 201402;
pub const __cpp_lib_string_udls: u32 = 201304;
pub const __cpp_lib_transformation_trait_aliases: u32 = 201304;
pub const __cpp_lib_tuple_element_t: u32 = 201402;
pub const __cpp_lib_tuples_by_type: u32 = 201304;
pub const __cpp_lib_addressof_constexpr: u32 = 201603;
pub const __cpp_lib_allocator_traits_is_always_equal: u32 = 201411;
pub const __cpp_lib_as_const: u32 = 201510;
pub const __cpp_lib_bool_constant: u32 = 201505;
pub const __cpp_lib_enable_shared_from_this: u32 = 201603;
pub const __cpp_lib_incomplete_container_elements: u32 = 201505;
pub const __cpp_lib_invoke: u32 = 201411;
pub const __cpp_lib_logical_traits: u32 = 201510;
pub const __cpp_lib_map_try_emplace: u32 = 201411;
pub const __cpp_lib_nonmember_container_access: u32 = 201411;
pub const __cpp_lib_shared_mutex: u32 = 201505;
pub const __cpp_lib_transparent_operators: u32 = 201510;
pub const __cpp_lib_type_trait_variable_templates: u32 = 201510;
pub const __cpp_lib_uncaught_exceptions: u32 = 201411;
pub const __cpp_lib_unordered_map_try_emplace: u32 = 201411;
pub const __cpp_lib_void_t: u32 = 201411;
pub const __cpp_lib_any: u32 = 201606;
pub const __cpp_lib_apply: u32 = 201603;
pub const __cpp_lib_atomic_is_always_lock_free: u32 = 201603;
pub const __cpp_lib_boyer_moore_searcher: u32 = 201603;
pub const __cpp_lib_byte: u32 = 201603;
pub const __cpp_lib_clamp: u32 = 201603;
pub const __cpp_lib_filesystem: u32 = 201703;
pub const __cpp_lib_gcd_lcm: u32 = 201606;
pub const __cpp_lib_hardware_interference_size: u32 = 201703;
pub const __cpp_lib_has_unique_object_representations: u32 = 201606;
pub const __cpp_lib_hypot: u32 = 201603;
pub const __cpp_lib_is_aggregate: u32 = 201703;
pub const __cpp_lib_is_invocable: u32 = 201703;
pub const __cpp_lib_is_swappable: u32 = 201603;
pub const __cpp_lib_launder: u32 = 201606;
pub const __cpp_lib_make_from_tuple: u32 = 201606;
pub const __cpp_lib_math_special_functions: u32 = 201603;
pub const __cpp_lib_memory_resource: u32 = 201603;
pub const __cpp_lib_node_extract: u32 = 201606;
pub const __cpp_lib_not_fn: u32 = 201603;
pub const __cpp_lib_parallel_algorithm: u32 = 201603;
pub const __cpp_lib_raw_memory_algorithms: u32 = 201606;
pub const __cpp_lib_sample: u32 = 201603;
pub const __cpp_lib_scoped_lock: u32 = 201703;
pub const __cpp_lib_shared_ptr_weak_type: u32 = 201606;
pub const __cpp_lib_string_view: u32 = 201803;
pub const __cpp_lib_to_chars: u32 = 201611;
pub const __cpp_lib_atomic_value_initialization: u32 = 201911;
pub const __cpp_lib_array_constexpr: u32 = 201803;
pub const __cpp_lib_chrono: u32 = 201611;
pub const __cpp_lib_execution: u32 = 201603;
pub const __cpp_lib_optional: u32 = 201606;
pub const __cpp_lib_shared_ptr_arrays: u32 = 201611;
pub const __cpp_lib_variant: u32 = 202102;
pub const __cpp_lib_experimental_erase_if: u32 = 201411;
pub const __cpp_lib_experimental_filesystem: u32 = 201406;
pub const _STL_WIN32_WINNT_VISTA: u32 = 1536;
pub const _STL_WIN32_WINNT_WIN7: u32 = 1537;
pub const _STL_WIN32_WINNT_WIN8: u32 = 1538;
pub const _STL_WIN32_WINNT_WINBLUE: u32 = 1539;
pub const _STL_WIN32_WINNT_WIN10: u32 = 2560;
pub const _STL_WIN32_WINNT: u32 = 1537;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_va_list_is_reference {
    pub _address: u8,
}
pub const __vcrt_va_list_is_reference___the_value: __vcrt_va_list_is_reference__bindgen_ty_1 =
    false;
pub type __vcrt_va_list_is_reference__bindgen_ty_1 = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __vcrt_assert_va_start_is_not_reference {
    pub _address: u8,
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Type {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BasicBlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CallableModule {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Module {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KernelModule {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PhiIncoming {
    pub block: *const BasicBlock,
    pub value: *const Node,
}
#[test]
fn bindgen_test_layout_PhiIncoming() {
    const UNINIT: ::std::mem::MaybeUninit<PhiIncoming> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PhiIncoming>(),
        16usize,
        concat!("Size of: ", stringify!(PhiIncoming))
    );
    assert_eq!(
        ::std::mem::align_of::<PhiIncoming>(),
        8usize,
        concat!("Alignment of ", stringify!(PhiIncoming))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PhiIncoming),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PhiIncoming),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwitchCase {
    pub value: i32,
    pub block: *const BasicBlock,
}
#[test]
fn bindgen_test_layout_SwitchCase() {
    const UNINIT: ::std::mem::MaybeUninit<SwitchCase> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SwitchCase>(),
        16usize,
        concat!("Size of: ", stringify!(SwitchCase))
    );
    assert_eq!(
        ::std::mem::align_of::<SwitchCase>(),
        8usize,
        concat!("Alignment of ", stringify!(SwitchCase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwitchCase),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SwitchCase),
            "::",
            stringify!(block)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CpuExternFn {
    pub data: *mut ::std::os::raw::c_void,
    pub func: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, args: *mut ::std::os::raw::c_void),
    >,
    pub dtor: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub arg_ty: *const Type,
}
#[test]
fn bindgen_test_layout_CpuExternFn() {
    const UNINIT: ::std::mem::MaybeUninit<CpuExternFn> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<CpuExternFn>(),
        32usize,
        concat!("Size of: ", stringify!(CpuExternFn))
    );
    assert_eq!(
        ::std::mem::align_of::<CpuExternFn>(),
        8usize,
        concat!("Alignment of ", stringify!(CpuExternFn))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuExternFn),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuExternFn),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dtor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuExternFn),
            "::",
            stringify!(dtor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arg_ty) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CpuExternFn),
            "::",
            stringify!(arg_ty)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Func {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Zero {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct One {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Assume {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Unreachable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ThreadId {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BlockId {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpSize {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpLaneId {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DispatchId {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DispatchSize {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PropagateGradient {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OutputGradient {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RequiresGradient {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Backward {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Gradient {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccGrad {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Detach {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayTracingInstanceTransform {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayTracingInstanceVisibilityMask {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayTracingInstanceUserId {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayTracingSetInstanceTransform {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayTracingSetInstanceOpacity {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayTracingSetInstanceVisibility {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayTracingSetInstanceUserId {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayTracingTraceClosest {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayTracingTraceAny {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayTracingQueryAll {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayTracingQueryAny {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayQueryWorldSpaceRay {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayQueryProceduralCandidateHit {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayQueryTriangleCandidateHit {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayQueryCommittedHit {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayQueryCommitTriangle {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayQueryCommitdProcedural {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RayQueryTerminate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Load {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Store {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cast {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitCast {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Add {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sub {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mul {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Div {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rem {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitAnd {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitOr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitXor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Shl {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Shr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RotRight {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RotLeft {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eq {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ne {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Lt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Le {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Gt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ge {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatCompMul {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Neg {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Not {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BitNot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct All {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Any {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Select {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Clamp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Lerp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Step {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Saturate {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SmoothStep {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Abs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Min {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Max {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReduceSum {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReduceProd {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReduceMin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReduceMax {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Clz {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ctz {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PopCount {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Reverse {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IsInf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IsNan {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Acos {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Acosh {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Asin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Asinh {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Atan {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Atan2 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Atanh {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cos {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cosh {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sinh {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tan {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tanh {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Exp {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Exp2 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Exp10 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Log {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Log2 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Log10 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Powi {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Powf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sqrt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Rsqrt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ceil {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Floor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fract {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Trunc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Round {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Fma {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Copysign {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Cross {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OuterProduct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Length {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LengthSquared {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Normalize {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Faceforward {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Distance {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Reflect {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Determinant {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Transpose {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Inverse {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpIsFirstActiveLane {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpFirstActiveLane {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpActiveAllEqual {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpActiveBitAnd {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpActiveBitOr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpActiveBitXor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpActiveCountBits {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpActiveMax {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpActiveMin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpActiveProduct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpActiveSum {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpActiveAll {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpActiveAny {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpActiveBitMask {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpPrefixCountBits {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpPrefixSum {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpPrefixProduct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpReadLaneAt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WarpReadFirstLane {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SynchronizeBlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AtomicExchange {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AtomicCompareExchange {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AtomicFetchAdd {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AtomicFetchSub {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AtomicFetchAnd {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AtomicFetchOr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AtomicFetchXor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AtomicFetchMin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AtomicFetchMax {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferWrite {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferRead {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferSize {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ByteBufferWrite {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ByteBufferRead {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ByteBufferSize {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Texture2dRead {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Texture2dWrite {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Texture2dSize {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Texture3dRead {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Texture3dWrite {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Texture3dSize {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessTexture2dSample {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessTexture2dSampleLevel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessTexture2dSampleGrad {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessTexture2dSampleGradLevel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessTexture2dRead {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessTexture2dSize {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessTexture2dSizeLevel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessTexture3dSample {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessTexture3dSampleLevel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessTexture3dSampleGrad {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessTexture3dSampleGradLevel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessTexture3dRead {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessTexture3dSize {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessTexture3dSizeLevel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessBufferWrite {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessBufferRead {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessBufferSize {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessByteBufferWrite {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessByteBufferRead {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessByteBufferSize {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec2 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec3 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec4 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Permute {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GetElementPtr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExtractElement {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct InsertElement {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Array {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MatFull {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mat2 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mat3 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Mat4 {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessAtomicFetchAdd {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessAtomicFetchSub {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessAtomicFetchAnd {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessAtomicFetchOr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessAtomicFetchXor {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessAtomicFetchMin {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessAtomicFetchMax {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Callable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CpuExt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ShaderExecutionReorder {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FuncTag {
    ZERO = 0,
    ONE = 1,
    ASSUME = 2,
    UNREACHABLE = 3,
    THREAD_ID = 4,
    BLOCK_ID = 5,
    WARP_SIZE = 6,
    WARP_LANE_ID = 7,
    DISPATCH_ID = 8,
    DISPATCH_SIZE = 9,
    PROPAGATE_GRADIENT = 10,
    OUTPUT_GRADIENT = 11,
    REQUIRES_GRADIENT = 12,
    BACKWARD = 13,
    GRADIENT = 14,
    ACC_GRAD = 15,
    DETACH = 16,
    RAY_TRACING_INSTANCE_TRANSFORM = 17,
    RAY_TRACING_INSTANCE_VISIBILITY_MASK = 18,
    RAY_TRACING_INSTANCE_USER_ID = 19,
    RAY_TRACING_SET_INSTANCE_TRANSFORM = 20,
    RAY_TRACING_SET_INSTANCE_OPACITY = 21,
    RAY_TRACING_SET_INSTANCE_VISIBILITY = 22,
    RAY_TRACING_SET_INSTANCE_USER_ID = 23,
    RAY_TRACING_TRACE_CLOSEST = 24,
    RAY_TRACING_TRACE_ANY = 25,
    RAY_TRACING_QUERY_ALL = 26,
    RAY_TRACING_QUERY_ANY = 27,
    RAY_QUERY_WORLD_SPACE_RAY = 28,
    RAY_QUERY_PROCEDURAL_CANDIDATE_HIT = 29,
    RAY_QUERY_TRIANGLE_CANDIDATE_HIT = 30,
    RAY_QUERY_COMMITTED_HIT = 31,
    RAY_QUERY_COMMIT_TRIANGLE = 32,
    RAY_QUERY_COMMITD_PROCEDURAL = 33,
    RAY_QUERY_TERMINATE = 34,
    LOAD = 35,
    STORE = 36,
    CAST = 37,
    BIT_CAST = 38,
    ADD = 39,
    SUB = 40,
    MUL = 41,
    DIV = 42,
    REM = 43,
    BIT_AND = 44,
    BIT_OR = 45,
    BIT_XOR = 46,
    SHL = 47,
    SHR = 48,
    ROT_RIGHT = 49,
    ROT_LEFT = 50,
    EQ = 51,
    NE = 52,
    LT = 53,
    LE = 54,
    GT = 55,
    GE = 56,
    MAT_COMP_MUL = 57,
    NEG = 58,
    NOT = 59,
    BIT_NOT = 60,
    ALL = 61,
    ANY = 62,
    SELECT = 63,
    CLAMP = 64,
    LERP = 65,
    STEP = 66,
    SATURATE = 67,
    SMOOTH_STEP = 68,
    ABS = 69,
    MIN = 70,
    MAX = 71,
    REDUCE_SUM = 72,
    REDUCE_PROD = 73,
    REDUCE_MIN = 74,
    REDUCE_MAX = 75,
    CLZ = 76,
    CTZ = 77,
    POP_COUNT = 78,
    REVERSE = 79,
    IS_INF = 80,
    IS_NAN = 81,
    ACOS = 82,
    ACOSH = 83,
    ASIN = 84,
    ASINH = 85,
    ATAN = 86,
    ATAN2 = 87,
    ATANH = 88,
    COS = 89,
    COSH = 90,
    SIN = 91,
    SINH = 92,
    TAN = 93,
    TANH = 94,
    EXP = 95,
    EXP2 = 96,
    EXP10 = 97,
    LOG = 98,
    LOG2 = 99,
    LOG10 = 100,
    POWI = 101,
    POWF = 102,
    SQRT = 103,
    RSQRT = 104,
    CEIL = 105,
    FLOOR = 106,
    FRACT = 107,
    TRUNC = 108,
    ROUND = 109,
    FMA = 110,
    COPYSIGN = 111,
    CROSS = 112,
    DOT = 113,
    OUTER_PRODUCT = 114,
    LENGTH = 115,
    LENGTH_SQUARED = 116,
    NORMALIZE = 117,
    FACEFORWARD = 118,
    DISTANCE = 119,
    REFLECT = 120,
    DETERMINANT = 121,
    TRANSPOSE = 122,
    INVERSE = 123,
    WARP_IS_FIRST_ACTIVE_LANE = 124,
    WARP_FIRST_ACTIVE_LANE = 125,
    WARP_ACTIVE_ALL_EQUAL = 126,
    WARP_ACTIVE_BIT_AND = 127,
    WARP_ACTIVE_BIT_OR = 128,
    WARP_ACTIVE_BIT_XOR = 129,
    WARP_ACTIVE_COUNT_BITS = 130,
    WARP_ACTIVE_MAX = 131,
    WARP_ACTIVE_MIN = 132,
    WARP_ACTIVE_PRODUCT = 133,
    WARP_ACTIVE_SUM = 134,
    WARP_ACTIVE_ALL = 135,
    WARP_ACTIVE_ANY = 136,
    WARP_ACTIVE_BIT_MASK = 137,
    WARP_PREFIX_COUNT_BITS = 138,
    WARP_PREFIX_SUM = 139,
    WARP_PREFIX_PRODUCT = 140,
    WARP_READ_LANE_AT = 141,
    WARP_READ_FIRST_LANE = 142,
    SYNCHRONIZE_BLOCK = 143,
    ATOMIC_EXCHANGE = 144,
    ATOMIC_COMPARE_EXCHANGE = 145,
    ATOMIC_FETCH_ADD = 146,
    ATOMIC_FETCH_SUB = 147,
    ATOMIC_FETCH_AND = 148,
    ATOMIC_FETCH_OR = 149,
    ATOMIC_FETCH_XOR = 150,
    ATOMIC_FETCH_MIN = 151,
    ATOMIC_FETCH_MAX = 152,
    BUFFER_WRITE = 153,
    BUFFER_READ = 154,
    BUFFER_SIZE = 155,
    BYTE_BUFFER_WRITE = 156,
    BYTE_BUFFER_READ = 157,
    BYTE_BUFFER_SIZE = 158,
    TEXTURE2D_READ = 159,
    TEXTURE2D_WRITE = 160,
    TEXTURE2D_SIZE = 161,
    TEXTURE3D_READ = 162,
    TEXTURE3D_WRITE = 163,
    TEXTURE3D_SIZE = 164,
    BINDLESS_TEXTURE2D_SAMPLE = 165,
    BINDLESS_TEXTURE2D_SAMPLE_LEVEL = 166,
    BINDLESS_TEXTURE2D_SAMPLE_GRAD = 167,
    BINDLESS_TEXTURE2D_SAMPLE_GRAD_LEVEL = 168,
    BINDLESS_TEXTURE2D_READ = 169,
    BINDLESS_TEXTURE2D_SIZE = 170,
    BINDLESS_TEXTURE2D_SIZE_LEVEL = 171,
    BINDLESS_TEXTURE3D_SAMPLE = 172,
    BINDLESS_TEXTURE3D_SAMPLE_LEVEL = 173,
    BINDLESS_TEXTURE3D_SAMPLE_GRAD = 174,
    BINDLESS_TEXTURE3D_SAMPLE_GRAD_LEVEL = 175,
    BINDLESS_TEXTURE3D_READ = 176,
    BINDLESS_TEXTURE3D_SIZE = 177,
    BINDLESS_TEXTURE3D_SIZE_LEVEL = 178,
    BINDLESS_BUFFER_WRITE = 179,
    BINDLESS_BUFFER_READ = 180,
    BINDLESS_BUFFER_SIZE = 181,
    BINDLESS_BYTE_BUFFER_WRITE = 182,
    BINDLESS_BYTE_BUFFER_READ = 183,
    BINDLESS_BYTE_BUFFER_SIZE = 184,
    VEC = 185,
    VEC2 = 186,
    VEC3 = 187,
    VEC4 = 188,
    PERMUTE = 189,
    GET_ELEMENT_PTR = 190,
    EXTRACT_ELEMENT = 191,
    INSERT_ELEMENT = 192,
    ARRAY = 193,
    STRUCT = 194,
    MAT_FULL = 195,
    MAT2 = 196,
    MAT3 = 197,
    MAT4 = 198,
    BINDLESS_ATOMIC_FETCH_ADD = 199,
    BINDLESS_ATOMIC_FETCH_SUB = 200,
    BINDLESS_ATOMIC_FETCH_AND = 201,
    BINDLESS_ATOMIC_FETCH_OR = 202,
    BINDLESS_ATOMIC_FETCH_XOR = 203,
    BINDLESS_ATOMIC_FETCH_MIN = 204,
    BINDLESS_ATOMIC_FETCH_MAX = 205,
    CALLABLE = 206,
    CPU_EXT = 207,
    SHADER_EXECUTION_REORDER = 208,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Instruction {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Texture2d {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Texture3d {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessArray {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Accel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Shared {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Uniform {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Argument {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Const {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Call {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Phi {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BasicBlockSentinel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct If {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GenericLoop {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Switch {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Local {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Break {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Continue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Return {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Print {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum InstructionTag {
    BUFFER = 0,
    TEXTURE2D = 1,
    TEXTURE3D = 2,
    BINDLESS_ARRAY = 3,
    ACCEL = 4,
    SHARED = 5,
    UNIFORM = 6,
    ARGUMENT = 7,
    CONST = 8,
    CALL = 9,
    PHI = 10,
    BASIC_BLOCK_SENTINEL = 11,
    IF = 12,
    GENERIC_LOOP = 13,
    SWITCH = 14,
    LOCAL = 15,
    BREAK = 16,
    CONTINUE = 17,
    RETURN = 18,
    PRINT = 19,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Binding {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BufferBinding {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TextureBinding {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BindlessArrayBinding {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AccelBinding {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BindingTag {
    BUFFER_BINDING = 0,
    TEXTURE_BINDING = 1,
    BINDLESS_ARRAY_BINDING = 2,
    ACCEL_BINDING = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Slice<T> {
    pub data: *mut T,
    pub len: usize,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Zero(self_: *mut Func) -> *mut Zero;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_One(self_: *mut Func) -> *mut One;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Assume(self_: *mut Func) -> *mut Assume;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Unreachable(self_: *mut Func) -> *mut Unreachable;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_ThreadId(self_: *mut Func) -> *mut ThreadId;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BlockId(self_: *mut Func) -> *mut BlockId;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpSize(self_: *mut Func) -> *mut WarpSize;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpLaneId(self_: *mut Func) -> *mut WarpLaneId;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_DispatchId(self_: *mut Func) -> *mut DispatchId;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_DispatchSize(self_: *mut Func) -> *mut DispatchSize;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_PropagateGradient(self_: *mut Func) -> *mut PropagateGradient;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_OutputGradient(self_: *mut Func) -> *mut OutputGradient;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RequiresGradient(self_: *mut Func) -> *mut RequiresGradient;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Backward(self_: *mut Func) -> *mut Backward;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Gradient(self_: *mut Func) -> *mut Gradient;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_AccGrad(self_: *mut Func) -> *mut AccGrad;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Detach(self_: *mut Func) -> *mut Detach;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayTracingInstanceTransform(
        self_: *mut Func,
    ) -> *mut RayTracingInstanceTransform;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayTracingInstanceVisibilityMask(
        self_: *mut Func,
    ) -> *mut RayTracingInstanceVisibilityMask;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayTracingInstanceUserId(
        self_: *mut Func,
    ) -> *mut RayTracingInstanceUserId;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayTracingSetInstanceTransform(
        self_: *mut Func,
    ) -> *mut RayTracingSetInstanceTransform;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayTracingSetInstanceOpacity(
        self_: *mut Func,
    ) -> *mut RayTracingSetInstanceOpacity;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayTracingSetInstanceVisibility(
        self_: *mut Func,
    ) -> *mut RayTracingSetInstanceVisibility;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayTracingSetInstanceUserId(
        self_: *mut Func,
    ) -> *mut RayTracingSetInstanceUserId;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayTracingTraceClosest(self_: *mut Func)
        -> *mut RayTracingTraceClosest;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayTracingTraceAny(self_: *mut Func) -> *mut RayTracingTraceAny;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayTracingQueryAll(self_: *mut Func) -> *mut RayTracingQueryAll;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayTracingQueryAny(self_: *mut Func) -> *mut RayTracingQueryAny;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayQueryWorldSpaceRay(self_: *mut Func) -> *mut RayQueryWorldSpaceRay;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayQueryProceduralCandidateHit(
        self_: *mut Func,
    ) -> *mut RayQueryProceduralCandidateHit;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayQueryTriangleCandidateHit(
        self_: *mut Func,
    ) -> *mut RayQueryTriangleCandidateHit;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayQueryCommittedHit(self_: *mut Func) -> *mut RayQueryCommittedHit;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayQueryCommitTriangle(self_: *mut Func)
        -> *mut RayQueryCommitTriangle;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayQueryCommitdProcedural(
        self_: *mut Func,
    ) -> *mut RayQueryCommitdProcedural;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RayQueryTerminate(self_: *mut Func) -> *mut RayQueryTerminate;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Load(self_: *mut Func) -> *mut Load;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Store(self_: *mut Func) -> *mut Store;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Cast(self_: *mut Func) -> *mut Cast;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BitCast(self_: *mut Func) -> *mut BitCast;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Add(self_: *mut Func) -> *mut Add;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Sub(self_: *mut Func) -> *mut Sub;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Mul(self_: *mut Func) -> *mut Mul;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Div(self_: *mut Func) -> *mut Div;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Rem(self_: *mut Func) -> *mut Rem;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BitAnd(self_: *mut Func) -> *mut BitAnd;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BitOr(self_: *mut Func) -> *mut BitOr;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BitXor(self_: *mut Func) -> *mut BitXor;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Shl(self_: *mut Func) -> *mut Shl;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Shr(self_: *mut Func) -> *mut Shr;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RotRight(self_: *mut Func) -> *mut RotRight;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_RotLeft(self_: *mut Func) -> *mut RotLeft;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Eq(self_: *mut Func) -> *mut Eq;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Ne(self_: *mut Func) -> *mut Ne;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Lt(self_: *mut Func) -> *mut Lt;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Le(self_: *mut Func) -> *mut Le;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Gt(self_: *mut Func) -> *mut Gt;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Ge(self_: *mut Func) -> *mut Ge;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_MatCompMul(self_: *mut Func) -> *mut MatCompMul;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Neg(self_: *mut Func) -> *mut Neg;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Not(self_: *mut Func) -> *mut Not;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BitNot(self_: *mut Func) -> *mut BitNot;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_All(self_: *mut Func) -> *mut All;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Any(self_: *mut Func) -> *mut Any;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Select(self_: *mut Func) -> *mut Select;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Clamp(self_: *mut Func) -> *mut Clamp;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Lerp(self_: *mut Func) -> *mut Lerp;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Step(self_: *mut Func) -> *mut Step;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Saturate(self_: *mut Func) -> *mut Saturate;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_SmoothStep(self_: *mut Func) -> *mut SmoothStep;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Abs(self_: *mut Func) -> *mut Abs;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Min(self_: *mut Func) -> *mut Min;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Max(self_: *mut Func) -> *mut Max;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_ReduceSum(self_: *mut Func) -> *mut ReduceSum;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_ReduceProd(self_: *mut Func) -> *mut ReduceProd;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_ReduceMin(self_: *mut Func) -> *mut ReduceMin;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_ReduceMax(self_: *mut Func) -> *mut ReduceMax;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Clz(self_: *mut Func) -> *mut Clz;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Ctz(self_: *mut Func) -> *mut Ctz;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_PopCount(self_: *mut Func) -> *mut PopCount;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Reverse(self_: *mut Func) -> *mut Reverse;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_IsInf(self_: *mut Func) -> *mut IsInf;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_IsNan(self_: *mut Func) -> *mut IsNan;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Acos(self_: *mut Func) -> *mut Acos;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Acosh(self_: *mut Func) -> *mut Acosh;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Asin(self_: *mut Func) -> *mut Asin;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Asinh(self_: *mut Func) -> *mut Asinh;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Atan(self_: *mut Func) -> *mut Atan;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Atan2(self_: *mut Func) -> *mut Atan2;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Atanh(self_: *mut Func) -> *mut Atanh;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Cos(self_: *mut Func) -> *mut Cos;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Cosh(self_: *mut Func) -> *mut Cosh;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Sin(self_: *mut Func) -> *mut Sin;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Sinh(self_: *mut Func) -> *mut Sinh;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Tan(self_: *mut Func) -> *mut Tan;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Tanh(self_: *mut Func) -> *mut Tanh;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Exp(self_: *mut Func) -> *mut Exp;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Exp2(self_: *mut Func) -> *mut Exp2;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Exp10(self_: *mut Func) -> *mut Exp10;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Log(self_: *mut Func) -> *mut Log;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Log2(self_: *mut Func) -> *mut Log2;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Log10(self_: *mut Func) -> *mut Log10;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Powi(self_: *mut Func) -> *mut Powi;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Powf(self_: *mut Func) -> *mut Powf;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Sqrt(self_: *mut Func) -> *mut Sqrt;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Rsqrt(self_: *mut Func) -> *mut Rsqrt;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Ceil(self_: *mut Func) -> *mut Ceil;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Floor(self_: *mut Func) -> *mut Floor;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Fract(self_: *mut Func) -> *mut Fract;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Trunc(self_: *mut Func) -> *mut Trunc;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Round(self_: *mut Func) -> *mut Round;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Fma(self_: *mut Func) -> *mut Fma;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Copysign(self_: *mut Func) -> *mut Copysign;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Cross(self_: *mut Func) -> *mut Cross;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Dot(self_: *mut Func) -> *mut Dot;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_OuterProduct(self_: *mut Func) -> *mut OuterProduct;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Length(self_: *mut Func) -> *mut Length;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_LengthSquared(self_: *mut Func) -> *mut LengthSquared;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Normalize(self_: *mut Func) -> *mut Normalize;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Faceforward(self_: *mut Func) -> *mut Faceforward;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Distance(self_: *mut Func) -> *mut Distance;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Reflect(self_: *mut Func) -> *mut Reflect;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Determinant(self_: *mut Func) -> *mut Determinant;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Transpose(self_: *mut Func) -> *mut Transpose;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Inverse(self_: *mut Func) -> *mut Inverse;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpIsFirstActiveLane(self_: *mut Func) -> *mut WarpIsFirstActiveLane;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpFirstActiveLane(self_: *mut Func) -> *mut WarpFirstActiveLane;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpActiveAllEqual(self_: *mut Func) -> *mut WarpActiveAllEqual;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpActiveBitAnd(self_: *mut Func) -> *mut WarpActiveBitAnd;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpActiveBitOr(self_: *mut Func) -> *mut WarpActiveBitOr;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpActiveBitXor(self_: *mut Func) -> *mut WarpActiveBitXor;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpActiveCountBits(self_: *mut Func) -> *mut WarpActiveCountBits;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpActiveMax(self_: *mut Func) -> *mut WarpActiveMax;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpActiveMin(self_: *mut Func) -> *mut WarpActiveMin;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpActiveProduct(self_: *mut Func) -> *mut WarpActiveProduct;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpActiveSum(self_: *mut Func) -> *mut WarpActiveSum;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpActiveAll(self_: *mut Func) -> *mut WarpActiveAll;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpActiveAny(self_: *mut Func) -> *mut WarpActiveAny;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpActiveBitMask(self_: *mut Func) -> *mut WarpActiveBitMask;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpPrefixCountBits(self_: *mut Func) -> *mut WarpPrefixCountBits;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpPrefixSum(self_: *mut Func) -> *mut WarpPrefixSum;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpPrefixProduct(self_: *mut Func) -> *mut WarpPrefixProduct;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpReadLaneAt(self_: *mut Func) -> *mut WarpReadLaneAt;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_WarpReadFirstLane(self_: *mut Func) -> *mut WarpReadFirstLane;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_SynchronizeBlock(self_: *mut Func) -> *mut SynchronizeBlock;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_AtomicExchange(self_: *mut Func) -> *mut AtomicExchange;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_AtomicCompareExchange(self_: *mut Func) -> *mut AtomicCompareExchange;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_AtomicFetchAdd(self_: *mut Func) -> *mut AtomicFetchAdd;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_AtomicFetchSub(self_: *mut Func) -> *mut AtomicFetchSub;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_AtomicFetchAnd(self_: *mut Func) -> *mut AtomicFetchAnd;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_AtomicFetchOr(self_: *mut Func) -> *mut AtomicFetchOr;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_AtomicFetchXor(self_: *mut Func) -> *mut AtomicFetchXor;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_AtomicFetchMin(self_: *mut Func) -> *mut AtomicFetchMin;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_AtomicFetchMax(self_: *mut Func) -> *mut AtomicFetchMax;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BufferWrite(self_: *mut Func) -> *mut BufferWrite;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BufferRead(self_: *mut Func) -> *mut BufferRead;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BufferSize(self_: *mut Func) -> *mut BufferSize;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_ByteBufferWrite(self_: *mut Func) -> *mut ByteBufferWrite;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_ByteBufferRead(self_: *mut Func) -> *mut ByteBufferRead;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_ByteBufferSize(self_: *mut Func) -> *mut ByteBufferSize;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Texture2dRead(self_: *mut Func) -> *mut Texture2dRead;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Texture2dWrite(self_: *mut Func) -> *mut Texture2dWrite;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Texture2dSize(self_: *mut Func) -> *mut Texture2dSize;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Texture3dRead(self_: *mut Func) -> *mut Texture3dRead;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Texture3dWrite(self_: *mut Func) -> *mut Texture3dWrite;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Texture3dSize(self_: *mut Func) -> *mut Texture3dSize;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessTexture2dSample(
        self_: *mut Func,
    ) -> *mut BindlessTexture2dSample;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessTexture2dSampleLevel(
        self_: *mut Func,
    ) -> *mut BindlessTexture2dSampleLevel;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessTexture2dSampleGrad(
        self_: *mut Func,
    ) -> *mut BindlessTexture2dSampleGrad;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessTexture2dSampleGradLevel(
        self_: *mut Func,
    ) -> *mut BindlessTexture2dSampleGradLevel;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessTexture2dRead(self_: *mut Func) -> *mut BindlessTexture2dRead;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessTexture2dSize(self_: *mut Func) -> *mut BindlessTexture2dSize;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessTexture2dSizeLevel(
        self_: *mut Func,
    ) -> *mut BindlessTexture2dSizeLevel;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessTexture3dSample(
        self_: *mut Func,
    ) -> *mut BindlessTexture3dSample;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessTexture3dSampleLevel(
        self_: *mut Func,
    ) -> *mut BindlessTexture3dSampleLevel;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessTexture3dSampleGrad(
        self_: *mut Func,
    ) -> *mut BindlessTexture3dSampleGrad;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessTexture3dSampleGradLevel(
        self_: *mut Func,
    ) -> *mut BindlessTexture3dSampleGradLevel;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessTexture3dRead(self_: *mut Func) -> *mut BindlessTexture3dRead;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessTexture3dSize(self_: *mut Func) -> *mut BindlessTexture3dSize;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessTexture3dSizeLevel(
        self_: *mut Func,
    ) -> *mut BindlessTexture3dSizeLevel;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessBufferWrite(self_: *mut Func) -> *mut BindlessBufferWrite;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessBufferRead(self_: *mut Func) -> *mut BindlessBufferRead;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessBufferSize(self_: *mut Func) -> *mut BindlessBufferSize;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessByteBufferWrite(
        self_: *mut Func,
    ) -> *mut BindlessByteBufferWrite;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessByteBufferRead(self_: *mut Func)
        -> *mut BindlessByteBufferRead;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessByteBufferSize(self_: *mut Func)
        -> *mut BindlessByteBufferSize;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Vec(self_: *mut Func) -> *mut Vec;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Vec2(self_: *mut Func) -> *mut Vec2;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Vec3(self_: *mut Func) -> *mut Vec3;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Vec4(self_: *mut Func) -> *mut Vec4;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Permute(self_: *mut Func) -> *mut Permute;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_GetElementPtr(self_: *mut Func) -> *mut GetElementPtr;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_ExtractElement(self_: *mut Func) -> *mut ExtractElement;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_InsertElement(self_: *mut Func) -> *mut InsertElement;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Array(self_: *mut Func) -> *mut Array;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Struct(self_: *mut Func) -> *mut Struct;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_MatFull(self_: *mut Func) -> *mut MatFull;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Mat2(self_: *mut Func) -> *mut Mat2;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Mat3(self_: *mut Func) -> *mut Mat3;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Mat4(self_: *mut Func) -> *mut Mat4;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessAtomicFetchAdd(self_: *mut Func)
        -> *mut BindlessAtomicFetchAdd;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessAtomicFetchSub(self_: *mut Func)
        -> *mut BindlessAtomicFetchSub;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessAtomicFetchAnd(self_: *mut Func)
        -> *mut BindlessAtomicFetchAnd;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessAtomicFetchOr(self_: *mut Func) -> *mut BindlessAtomicFetchOr;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessAtomicFetchXor(self_: *mut Func)
        -> *mut BindlessAtomicFetchXor;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessAtomicFetchMin(self_: *mut Func)
        -> *mut BindlessAtomicFetchMin;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_BindlessAtomicFetchMax(self_: *mut Func)
        -> *mut BindlessAtomicFetchMax;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_Callable(self_: *mut Func) -> *mut Callable;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_CpuExt(self_: *mut Func) -> *mut CpuExt;
}
extern "C" {
    pub fn lc_ir_v2_Func_as_ShaderExecutionReorder(self_: *mut Func)
        -> *mut ShaderExecutionReorder;
}
extern "C" {
    pub fn lc_ir_v2_Func_tag(self_: *mut Func) -> FuncTag;
}
extern "C" {
    pub fn lc_ir_v2_Assume_msg(self_: *mut Assume, out: *mut Slice<::std::os::raw::c_char>);
}
extern "C" {
    pub fn lc_ir_v2_Unreachable_msg(
        self_: *mut Unreachable,
        out: *mut Slice<::std::os::raw::c_char>,
    );
}
extern "C" {
    pub fn lc_ir_v2_BindlessAtomicFetchAdd_ty(
        self_: *mut BindlessAtomicFetchAdd,
        out: *mut *const Type,
    );
}
extern "C" {
    pub fn lc_ir_v2_BindlessAtomicFetchSub_ty(
        self_: *mut BindlessAtomicFetchSub,
        out: *mut *const Type,
    );
}
extern "C" {
    pub fn lc_ir_v2_BindlessAtomicFetchAnd_ty(
        self_: *mut BindlessAtomicFetchAnd,
        out: *mut *const Type,
    );
}
extern "C" {
    pub fn lc_ir_v2_BindlessAtomicFetchOr_ty(
        self_: *mut BindlessAtomicFetchOr,
        out: *mut *const Type,
    );
}
extern "C" {
    pub fn lc_ir_v2_BindlessAtomicFetchXor_ty(
        self_: *mut BindlessAtomicFetchXor,
        out: *mut *const Type,
    );
}
extern "C" {
    pub fn lc_ir_v2_BindlessAtomicFetchMin_ty(
        self_: *mut BindlessAtomicFetchMin,
        out: *mut *const Type,
    );
}
extern "C" {
    pub fn lc_ir_v2_BindlessAtomicFetchMax_ty(
        self_: *mut BindlessAtomicFetchMax,
        out: *mut *const Type,
    );
}
extern "C" {
    pub fn lc_ir_v2_Callable_module(self_: *mut Callable, out: *mut *mut CallableModule);
}
extern "C" {
    pub fn lc_ir_v2_CpuExt_f(self_: *mut CpuExt, out: *mut CpuExternFn);
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Buffer(self_: *mut Instruction) -> *mut Buffer;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Texture2d(self_: *mut Instruction) -> *mut Texture2d;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Texture3d(self_: *mut Instruction) -> *mut Texture3d;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_BindlessArray(self_: *mut Instruction) -> *mut BindlessArray;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Accel(self_: *mut Instruction) -> *mut Accel;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Shared(self_: *mut Instruction) -> *mut Shared;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Uniform(self_: *mut Instruction) -> *mut Uniform;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Argument(self_: *mut Instruction) -> *mut Argument;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Const(self_: *mut Instruction) -> *mut Const;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Call(self_: *mut Instruction) -> *mut Call;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Phi(self_: *mut Instruction) -> *mut Phi;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_BasicBlockSentinel(
        self_: *mut Instruction,
    ) -> *mut BasicBlockSentinel;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_If(self_: *mut Instruction) -> *mut If;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_GenericLoop(self_: *mut Instruction) -> *mut GenericLoop;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Switch(self_: *mut Instruction) -> *mut Switch;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Local(self_: *mut Instruction) -> *mut Local;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Break(self_: *mut Instruction) -> *mut Break;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Continue(self_: *mut Instruction) -> *mut Continue;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Return(self_: *mut Instruction) -> *mut Return;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_as_Print(self_: *mut Instruction) -> *mut Print;
}
extern "C" {
    pub fn lc_ir_v2_Instruction_tag(self_: *mut Instruction) -> InstructionTag;
}
extern "C" {
    pub fn lc_ir_v2_Argument_by_value(self_: *mut Argument, out: *mut bool);
}
extern "C" {
    pub fn lc_ir_v2_Const_ty(self_: *mut Const, out: *mut *const Type);
}
extern "C" {
    pub fn lc_ir_v2_Const_value(self_: *mut Const, out: *mut Slice<u8>);
}
extern "C" {
    pub fn lc_ir_v2_Call_func(self_: *mut Call, out: *mut *const Func);
}
extern "C" {
    pub fn lc_ir_v2_Call_args(self_: *mut Call, out: *mut Slice<*mut Node>);
}
extern "C" {
    pub fn lc_ir_v2_Phi_incomings(self_: *mut Phi, out: *mut Slice<PhiIncoming>);
}
extern "C" {
    pub fn lc_ir_v2_If_cond(self_: *mut If, out: *mut *mut Node);
}
extern "C" {
    pub fn lc_ir_v2_If_true_branch(self_: *mut If, out: *mut *mut BasicBlock);
}
extern "C" {
    pub fn lc_ir_v2_If_false_branch(self_: *mut If, out: *mut *mut BasicBlock);
}
extern "C" {
    pub fn lc_ir_v2_GenericLoop_prepare(self_: *mut GenericLoop, out: *mut *mut BasicBlock);
}
extern "C" {
    pub fn lc_ir_v2_GenericLoop_cond(self_: *mut GenericLoop, out: *mut *mut Node);
}
extern "C" {
    pub fn lc_ir_v2_GenericLoop_body(self_: *mut GenericLoop, out: *mut *mut BasicBlock);
}
extern "C" {
    pub fn lc_ir_v2_GenericLoop_update(self_: *mut GenericLoop, out: *mut *mut BasicBlock);
}
extern "C" {
    pub fn lc_ir_v2_Switch_value(self_: *mut Switch, out: *mut *mut Node);
}
extern "C" {
    pub fn lc_ir_v2_Switch_cases(self_: *mut Switch, out: *mut Slice<SwitchCase>);
}
extern "C" {
    pub fn lc_ir_v2_Switch_default_(self_: *mut Switch, out: *mut *mut BasicBlock);
}
extern "C" {
    pub fn lc_ir_v2_Local_init(self_: *mut Local, out: *mut *mut Node);
}
extern "C" {
    pub fn lc_ir_v2_Return_value(self_: *mut Return, out: *mut *mut Node);
}
extern "C" {
    pub fn lc_ir_v2_Print_fmt(self_: *mut Print, out: *mut Slice<::std::os::raw::c_char>);
}
extern "C" {
    pub fn lc_ir_v2_Print_args(self_: *mut Print, out: *mut Slice<*mut Node>);
}
extern "C" {
    pub fn lc_ir_v2_Binding_as_BufferBinding(self_: *mut Binding) -> *mut BufferBinding;
}
extern "C" {
    pub fn lc_ir_v2_Binding_as_TextureBinding(self_: *mut Binding) -> *mut TextureBinding;
}
extern "C" {
    pub fn lc_ir_v2_Binding_as_BindlessArrayBinding(
        self_: *mut Binding,
    ) -> *mut BindlessArrayBinding;
}
extern "C" {
    pub fn lc_ir_v2_Binding_as_AccelBinding(self_: *mut Binding) -> *mut AccelBinding;
}
extern "C" {
    pub fn lc_ir_v2_Binding_tag(self_: *mut Binding) -> BindingTag;
}
extern "C" {
    pub fn lc_ir_v2_BufferBinding_handle(self_: *mut BufferBinding, out: *mut u64);
}
extern "C" {
    pub fn lc_ir_v2_BufferBinding_offset(self_: *mut BufferBinding, out: *mut u64);
}
extern "C" {
    pub fn lc_ir_v2_BufferBinding_size(self_: *mut BufferBinding, out: *mut u64);
}
extern "C" {
    pub fn lc_ir_v2_TextureBinding_handle(self_: *mut TextureBinding, out: *mut u64);
}
extern "C" {
    pub fn lc_ir_v2_TextureBinding_level(self_: *mut TextureBinding, out: *mut u64);
}
extern "C" {
    pub fn lc_ir_v2_BindlessArrayBinding_handle(self_: *mut BindlessArrayBinding, out: *mut u64);
}
extern "C" {
    pub fn lc_ir_v2_AccelBinding_handle(self_: *mut AccelBinding, out: *mut u64);
}
